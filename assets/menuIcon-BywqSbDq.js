function c(i,t){return Math.round(i/t)*t}function m(i,t){return Math.floor(i/t)*t}function o(i){return i*(Math.PI/180)}function h(i,t,e){return i*(1-e)+t*e}class l{static magnitudeSquared(t){return t.x*t.x+t.y*t.y}static magnitude(t){const e=Math.sqrt(this.magnitudeSquared(t));return isNaN(e)?0:e}static normalize(t){const e=this.magnitude(t);return e===0?{x:0,y:0}:this.divide(t,e)}static dot(t,e){return t.x*e.x+t.y*e.y}static subtract(t,e){return typeof e=="number"?{x:t.x-e,y:t.y-e}:{x:t.x-e.x,y:t.y-e.y}}static add(t,e){return typeof e=="number"?{x:t.x+e,y:t.y+e}:{x:t.x+e.x,y:t.y+e.y}}static multiply(t,e){return typeof e=="number"?{x:t.x*e,y:t.y*e}:{x:t.x*e.x,y:t.y*e.y}}static divide(t,e){return typeof e=="number"?{x:t.x/e,y:t.y/e}:{x:t.x/e.x,y:t.y/e.y}}static rotate(t,e,r){const x=Math.cos(o(r)),n=Math.sin(o(r)),y=this.subtract(t,e);return{x:e.x+x*y.x-n*y.y,y:e.y+n*y.x+x*y.y}}static min(t,e){return typeof e=="number"?{x:Math.min(t.x,e),y:Math.min(t.y,e)}:{x:Math.min(t.x,e.x),y:Math.min(t.y,e.y)}}static componentMin(t){return t.x<t.y?t.x:t.y}static max(t,e){return typeof e=="number"?{x:Math.max(t.x,e),y:Math.max(t.y,e)}:{x:Math.max(t.x,e.x),y:Math.max(t.y,e.y)}}static componentMax(t){return t.x>t.y?t.x:t.y}static roundTo(t,e){return{x:c(t.x,e.x),y:c(t.y,e.y)}}static floorTo(t,e){return{x:m(t.x,e.x),y:m(t.y,e.y)}}static sign(t){return{x:Math.sign(t.x),y:Math.sign(t.y)}}static abs(t){return{x:Math.abs(t.x),y:Math.abs(t.y)}}static pow(t,e){return typeof e=="number"?{x:Math.pow(t.x,e),y:Math.pow(t.y,e)}:{x:Math.pow(t.x,e.x),y:Math.pow(t.y,e.y)}}static clamp(t,e,r){return{x:Math.min(Math.max(t.x,e),r),y:Math.min(Math.max(t.y,e),r)}}static boundingBox(t){let e=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,x=Number.MAX_SAFE_INTEGER,n=Number.MIN_SAFE_INTEGER;for(let u of t)e=u.x<e?u.x:e,r=u.x>r?u.x:r,x=u.y<x?u.y:x,n=u.y>n?u.y:n;let y=r-e,s=n-x,a={x:(e+r)/2,y:(x+n)/2};return{min:{x:e,y:x},max:{x:r,y:n},width:y,height:s,center:a}}static pointInPolygon(t,e){const r=this.boundingBox(e);if(t.x<r.min.x||t.x>r.max.x||t.y<r.min.y||t.y>r.max.y)return!1;let x=!1;for(let n=0,y=e.length-1;n<e.length;y=n++){const s=e[n].y>t.y,a=e[y].y>t.y;s!==a&&t.x<(e[y].x-e[n].x)*(t.y-e[n].y)/(e[y].y-e[n].y)+e[n].x&&(x=!x)}return x}static compare(t,e,r){return this.magnitudeSquared(this.subtract(t,e))<r*r}static distance(t,e){return this.magnitude(this.subtract(t,e))}static lerp(t,e,r){return{x:h(t.x,e.x,r),y:h(t.y,e.y,r)}}static centroid(t){let e={x:0,y:0};for(let r of t)e.x+=r.x,e.y+=r.y;return t.length>0&&(e={x:e.x/t.length,y:e.y/t.length}),e}}const f=new URL(""+new URL("status-C1DYj_3p.svg#icon",import.meta.url).href,import.meta.url).toString();export{l as M,f as m};
